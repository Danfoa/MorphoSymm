import functools
import itertools
from collections import OrderedDict
from typing import Dict

import numpy as np
from escnn.group import CyclicGroup, DihedralGroup, DirectProductGroup, Group, GroupElement
from escnn.group.representation import Representation, directsum

from morpho_symm.groups.isotypic_decomposition import escnn_representation_form_mapping
from morpho_symm.utils.algebra_utils import permutation_matrix


def generate_cyclic_rep(G: CyclicGroup, rep):
    """Generate cylic froup form a representation of its generator."""
    h = G.generators[0]
    # Check the given matrix representations comply with group axioms
    assert not np.allclose(rep[h], rep[G.identity]), "Invalid generator: h=e"
    assert np.allclose(np.linalg.matrix_power(rep[h], G.order()), rep[G.identity]), \
        f"Invalid rotation generator h_ref^{G.order()} != I"

    curr_g = h
    while len(rep) < G.order():  # Use generator to obtain all elements and element reps in group
        g = curr_g @ h
        rep[g] = rep[curr_g] @ rep[h]
        curr_g = g

    return rep


def generate_dihedral_rep(G: DihedralGroup, rep):
    """Generate dihedral group form a representation of its generators."""
    h_rot, h_ref = G.generators
    # Check the given matrix representations comply with group axioms
    # assert not np.allclose(rep[h_ref], rep[G.identity]), "Invalid reflection generator: h_ref=e"
    # assert not np.allclose(rep[h_rot], rep[G.identity]), "Invalid rotation generator: h_rot=e"
    assert np.allclose(rep[h_ref] @ rep[h_ref], rep[G.identity]), "Invalid reflection generator `h_ref @ h_ref != I`"
    assert np.allclose(np.linalg.matrix_power(rep[h_rot], G.order() // 2), rep[G.identity]), \
        f"Invalid rotation generator h_ref^{G.order} != I"

    curr_g, curr_ref_g = h_rot, h_ref @ h_rot
    rep[curr_ref_g] = rep[h_ref] @ rep[h_rot]
    while len(rep) < G.order():  # Use generator to obtain all elements and element reps in group
        g = curr_g @ h_rot
        gr = curr_ref_g @ h_rot
        rep[g] = rep[curr_g] @ rep[h_rot]
        rep[gr] = rep[curr_ref_g] @ rep[h_rot]
        curr_g, curr_ref_g = g, gr

    return rep


def generate_direct_product_rep(G: DirectProductGroup, rep1, rep2):
    """Generate direct product group form the two representations of each group generators."""
    rep = {}
    for h1, h2 in itertools.product(rep1.keys(), rep2.keys()):
        g = G.pair_elements(h1, h2)
        rep[g] = rep1[h1] @ rep2[h2]
    return rep


def group_rep_from_gens(G: Group, rep_H: Dict[GroupElement, np.ndarray]) -> Representation:
    """Generate a representation of all group actions from the representations of the group generators H={h1, h2, ...}.

    Such that any group action `g` can be obtained by multiplying the generators `h1`, `h2`, ... in `H`.
    Being all `h` in `H`
    Args:
        G (Group): Group to generate representation for.
        rep_H (Dict[GroupElement, np.ndarray]): Representation of the group generators H={h1, h2, ...}.

    Returns:
        Representation: ESCNN Representation of group actions generated by the input rep..
    """
    if G.identity not in rep_H:
        rep_H[G.identity] = np.eye(list(rep_H.values())[0].shape[0])

    if isinstance(G, CyclicGroup):
        rep_H = generate_cyclic_rep(G, rep_H)
    elif isinstance(G, DihedralGroup):
        rep_H = generate_dihedral_rep(G, rep_H)
    elif isinstance(G, DirectProductGroup):
        # Extract the generators of first and second group, generate the groups independently and then combine them
        H1, H2 = zip(*[G.split_element(h) for h in G.generators])
        rep_G1 = {G.G1.identity: rep_H[G.pair_elements(G.G1.identity, G.G2.identity)]}
        rep_G2 = {G.G2.identity: rep_H[G.pair_elements(G.G1.identity, G.G2.identity)]}
        rep_G1.update({h1: rep_H[G.inclusion1(h1)] for h1 in H1})
        rep_G2.update({h2: rep_H[G.inclusion2(h2)] for h2 in H2})

        # generate each subgroup representation
        group_rep_from_gens(G.G1, rep_G1)
        group_rep_from_gens(G.G2, rep_G2)

        # Do direct product of the generated subgroups reps.
        rep_H = generate_direct_product_rep(G, rep_G1, rep_G2)
    else:
        raise NotImplementedError(f"Group {G} not implemented yet.")

    # Convert Dict[GroupElement, np.ndarray] to escnn `Representation`
    rep_escnn = escnn_representation_form_mapping(G, rep_H)
    return rep_escnn


def irreps_stats(irreps_ids):
    str_ids = [str(irrep_id) for irrep_id in irreps_ids]
    unique_str_ids, counts, indices = np.unique(str_ids, return_counts=True, return_index=True)
    unique_ids = [eval(s) for s in unique_str_ids]
    return unique_ids, counts, indices


def isotypic_decomp_representation(rep: Representation) -> [Representation]:
    """Returns a representation in a "symmetry enabled basis" (a.k.a Isotypic Basis).

    Takes a representation with an arbitrary basis (i.e., arbitrary change of basis and an arbitrary order of
    irreducible representations in the escnn Representation) and returns a new representation in which the basis
    is changed to a "symmetry enabled basis" (a.k.a Isotypic Basis). That is a representation in which the
    vector space is decomposed into a direct sum of Isotypic Subspaces. Each Isotypic Subspace is a subspace of the
    original vector space with a subspace representation composed of multiplicities of a single irreducible
    representation. In oder words, each Isotypic Subspace is a subspace with a subgroup of symmetries of the original
    vector space's symmetry group.

    Args:
        rep (Representation): Input representation in any arbitrary basis.

    Returns: A `Representation` with a change of basis exposing an Isotypic Basis (a.k.a symmetry enabled basis).
        The instance of the representation contains an additional attribute `isotypic_subspaces` which is an
        `OrderedDict` of representations per each isotypic subspace. The keys are the active irreps' ids associated
        with each Isotypic subspace.
    """
    symm_group = rep.group
    potential_irreps = rep.group.irreps()
    isotypic_subspaces_indices = {irrep.id: [] for irrep in potential_irreps}

    for pot_irrep in potential_irreps:
        cur_dim = 0
        for rep_irrep_id in rep.irreps:
            rep_irrep = symm_group.irrep(*rep_irrep_id)
            if rep_irrep == pot_irrep:
                isotypic_subspaces_indices[rep_irrep_id].append(list(range(cur_dim, cur_dim + rep_irrep.size)))
            cur_dim += rep_irrep.size

    # Remove inactive Isotypic Spaces
    for irrep in potential_irreps:
        if len(isotypic_subspaces_indices[irrep.id]) == 0:
            del isotypic_subspaces_indices[irrep.id]

    # Each Isotypic Space will be indexed by the irrep it is associated with.
    active_isotypic_reps = {}
    for irrep_id, indices in isotypic_subspaces_indices.items():
        irrep = symm_group.irrep(*irrep_id)
        multiplicities = len(indices)
        active_isotypic_reps[irrep_id] = Representation(group=rep.group,
                                                        irreps=[irrep_id] * multiplicities,
                                                        name=f'IsoSubspace {irrep_id}',
                                                        change_of_basis=np.identity(irrep.size * multiplicities),
                                                        supported_nonlinearities=irrep.supported_nonlinearities)

    # Impose canonical order on the Isotypic Subspaces.
    # If the trivial representation is active it will be the first Isotypic Subspace.
    # Then sort by dimension of the space from smallest to largest.
    ordered_isotypic_reps = OrderedDict(sorted(active_isotypic_reps.items(), key=lambda item: item[1].size))
    if symm_group.trivial_representation.id in ordered_isotypic_reps.keys():
        ordered_isotypic_reps.move_to_end(symm_group.trivial_representation.id, last=False)

    # Required permutation to change the order of the irreps. So we obtain irreps of the same type consecutively.
    oneline_permutation = []
    for irrep_id, iso_rep in ordered_isotypic_reps.items():
        idx = isotypic_subspaces_indices[irrep_id]
        oneline_permutation.extend(idx)
    oneline_permutation = np.concatenate(oneline_permutation)
    P_in2iso = permutation_matrix(oneline_permutation)

    Q_iso = rep.change_of_basis @ P_in2iso.T
    rep_iso_basis = directsum(list(ordered_isotypic_reps.values()),
                              name=rep.name + '-Iso',
                              change_of_basis=Q_iso)

    iso_supported_nonlinearities = [iso_rep.supported_nonlinearities for iso_rep in ordered_isotypic_reps.values()]
    rep_iso_basis.supported_nonlinearities = functools.reduce(set.intersection, iso_supported_nonlinearities)
    rep_iso_basis.attributes['isotypic_reps'] = ordered_isotypic_reps

    return rep_iso_basis


def isotypic_basis(representation: Representation, multiplicity: int = 1, prefix=''):
    rep_iso = isotypic_decomp_representation(representation)

    iso_reps = OrderedDict()
    iso_range = OrderedDict()

    start_dim = 0
    for iso_irrep_id, reg_rep_iso in rep_iso.attributes['isotypic_reps'].items():
        iso_reps[iso_irrep_id] = directsum([reg_rep_iso] * multiplicity, name=f"{prefix}_IsoSpace{iso_irrep_id}")
        iso_range[iso_irrep_id] = range(start_dim, start_dim + iso_reps[iso_irrep_id].size)
        start_dim += iso_reps[iso_irrep_id].size

    assert rep_iso.size * multiplicity == sum([iso_rep.size for iso_rep in iso_reps.values()])

    return iso_reps, iso_range  # Dict[key:id_space -> value: rep_iso_space]