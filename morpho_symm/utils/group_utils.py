import itertools
from typing import Dict

import numpy as np
from escnn.group import CyclicGroup, DihedralGroup, DirectProductGroup, Group, GroupElement
from escnn.group.representation import Representation

from morpho_symm.groups.isotypic_decomposition import escnn_representation_form_mapping


def generate_cyclic_rep(G: CyclicGroup, rep):
    """Generate cylic froup form a representation of its generator."""
    h = G.generators[0]
    # Check the given matrix representations comply with group axioms
    assert not np.allclose(rep[h], rep[G.identity]), "Invalid generator: h=e"
    assert np.allclose(np.linalg.matrix_power(rep[h], G.order()), rep[G.identity]), \
        f"Invalid rotation generator h_ref^{G.order()} != I"

    curr_g = h
    while len(rep) < G.order():  # Use generator to obtain all elements and element reps in group
        g = curr_g @ h
        rep[g] = rep[curr_g] @ rep[h]
        curr_g = g

    return rep


def generate_dihedral_rep(G: DihedralGroup, rep):
    """Generate dihedral group form a representation of its generators."""
    h_rot, h_ref = G.generators
    # Check the given matrix representations comply with group axioms
    # assert not np.allclose(rep[h_ref], rep[G.identity]), "Invalid reflection generator: h_ref=e"
    # assert not np.allclose(rep[h_rot], rep[G.identity]), "Invalid rotation generator: h_rot=e"
    assert np.allclose(rep[h_ref] @ rep[h_ref], rep[G.identity]), "Invalid reflection generator `h_ref @ h_ref != I`"
    assert np.allclose(np.linalg.matrix_power(rep[h_rot], G.order()//2), rep[G.identity]),\
        f"Invalid rotation generator h_ref^{G.order} != I"

    curr_g, curr_ref_g = h_rot, h_ref @ h_rot
    rep[curr_ref_g] = rep[h_ref] @ rep[h_rot]
    while len(rep) < G.order():  # Use generator to obtain all elements and element reps in group
        g = curr_g @ h_rot
        gr = curr_ref_g @ h_rot
        rep[g] = rep[curr_g] @ rep[h_rot]
        rep[gr] = rep[curr_ref_g] @ rep[h_rot]
        curr_g, curr_ref_g = g, gr

    return rep


def generate_direct_product_rep(G: DirectProductGroup, rep1, rep2):
    """Generate direct product group form the two representations of each group generators."""
    rep = {}
    for h1, h2 in itertools.product(rep1.keys(), rep2.keys()):
        g = G.pair_elements(h1, h2)
        rep[g] = rep1[h1] @ rep2[h2]
    return rep


def group_rep_from_gens(G: Group, rep_H: Dict[GroupElement, np.ndarray]) -> Representation:
    """Generate a representation of all group actions from the representations of the group generators H={h1, h2, ...}.

    Such that any group action `g` can be obtained by multiplying the generators `h1`, `h2`, ... in `H`.
    Being all `h` in `H`
    Args:
        G (Group): Group to generate representation for.
        rep_H (Dict[GroupElement, np.ndarray]): Representation of the group generators H={h1, h2, ...}.

    Returns:
        Representation: ESCNN Representation of group actions generated by the input rep..
    """
    if G.identity not in rep_H:
        rep_H[G.identity] = np.eye(list(rep_H.values())[0].shape[0])

    if isinstance(G, CyclicGroup):
        rep_H = generate_cyclic_rep(G, rep_H)
    elif isinstance(G, DihedralGroup):
        rep_H = generate_dihedral_rep(G, rep_H)
    elif isinstance(G, DirectProductGroup):
        # Extract the generators of first and second group, generate the groups independently and then combine them
        H1, H2 = zip(*[G.split_element(h) for h in G.generators])
        rep_G1 = {G.G1.identity: rep_H[G.pair_elements(G.G1.identity, G.G2.identity)]}
        rep_G2 = {G.G2.identity: rep_H[G.pair_elements(G.G1.identity, G.G2.identity)]}
        rep_G1.update({h1: rep_H[G.inclusion1(h1)] for h1 in H1})
        rep_G2.update({h2: rep_H[G.inclusion2(h2)] for h2 in H2})

        # generate each subgroup representation
        group_rep_from_gens(G.G1, rep_G1)
        group_rep_from_gens(G.G2, rep_G2)

        # Do direct product of the generated subgroups reps.
        rep_H = generate_direct_product_rep(G, rep_G1, rep_G2)
    else:
        raise NotImplementedError(f"Group {G} not implemented yet.")

    # Convert Dict[GroupElement, np.ndarray] to escnn `Representation`
    rep_escnn = escnn_representation_form_mapping(G, rep_H)

    return rep_escnn



